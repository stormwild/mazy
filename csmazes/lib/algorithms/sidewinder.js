// Generated by CoffeeScript 1.12.6

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.Sidewinder = (function(superClass) {
  extend(Sidewinder, superClass);

  Sidewinder.prototype.IN = 0x1000;

  Sidewinder.prototype.isCurrent = function(x, y) {
    return this.x === x && this.y === y;
  };

  function Sidewinder(maze, options) {
    Sidewinder.__super__.constructor.apply(this, arguments);
    this.x = 0;
    this.y = 0;
    this.runStart = 0;
    this.state = 0;
  }

  Sidewinder.prototype.step = function() {
    var cell, oldX, oldY, ref;
    if (this.y >= this.maze.height) {
      return false;
    }
    if (this.y > 0 && (this.x + 1 >= this.maze.width || this.rand.nextBoolean())) {
      cell = this.runStart + this.rand.nextInteger(this.x - this.runStart + 1);
      this.maze.carve(cell, this.y, Maze.Direction.N);
      this.maze.carve(cell, this.y - 1, Maze.Direction.S);
      this.updateAt(cell, this.y);
      this.updateAt(cell, this.y - 1);
      if (this.x - this.runStart > 0) {
        this.eventAt(this.x, this.y);
      }
      this.runStart = this.x + 1;
    } else if (this.x + 1 < this.maze.width) {
      this.maze.carve(this.x, this.y, Maze.Direction.E);
      this.maze.carve(this.x + 1, this.y, Maze.Direction.W);
      this.updateAt(this.x, this.y);
      this.updateAt(this.x + 1, this.y);
    } else {
      this.maze.carve(this.x, this.y, this.IN);
      this.updateAt(this.x, this.y);
    }
    ref = [this.x, this.y], oldX = ref[0], oldY = ref[1];
    this.x++;
    if (this.x >= this.maze.width) {
      this.x = 0;
      this.runStart = 0;
      this.y++;
    }
    this.updateAt(oldX, oldY);
    this.updateAt(this.x, this.y);
    return this.y < this.maze.height;
  };

  return Sidewinder;

})(Maze.Algorithm);
