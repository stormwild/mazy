// Generated by CoffeeScript 1.12.6

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.Eller = (function(superClass) {
  extend(Eller, superClass);

  Eller.prototype.IN = 0x1000;

  Eller.prototype.HORIZONTAL = 0;

  Eller.prototype.VERTICAL = 1;

  function Eller(maze, options) {
    Eller.__super__.constructor.apply(this, arguments);
    this.state = new Maze.Algorithms.Eller.State(this.maze.width).populate();
    this.row = 0;
    this.pending = true;
    this.initializeRow();
  }

  Eller.prototype.initializeRow = function() {
    this.column = 0;
    return this.mode = this.HORIZONTAL;
  };

  Eller.prototype.isFinal = function() {
    return this.row + 1 === this.maze.height;
  };

  Eller.prototype.isIn = function(x, y) {
    return this.maze.isValid(x, y) && this.maze.isSet(x, y, this.IN);
  };

  Eller.prototype.isCurrent = function(x, y) {
    return this.column === x && this.row === y;
  };

  Eller.prototype.horizontalStep = function() {
    var oldColumn, ref;
    if (!this.state.isSame(this.column, this.column + 1) && (this.isFinal() || this.rand.nextBoolean())) {
      this.state.merge(this.column, this.column + 1);
      this.maze.carve(this.column, this.row, Maze.Direction.E);
      this.updateAt(this.column, this.row);
      this.maze.carve(this.column + 1, this.row, Maze.Direction.W);
      this.updateAt(this.column + 1, this.row);
    } else if (this.maze.isBlank(this.column, this.row)) {
      this.maze.carve(this.column, this.row, this.IN);
      this.updateAt(this.column, this.row);
    }
    this.column += 1;
    if (this.column > 0) {
      this.updateAt(this.column - 1, this.row);
    }
    this.updateAt(this.column, this.row);
    if (this.column + 1 >= this.maze.width) {
      if (this.maze.isBlank(this.column, this.row)) {
        this.maze.carve(this.column, this.row, this.IN);
        this.updateAt(this.column, this.row);
      }
      if (this.isFinal()) {
        this.pending = false;
        ref = [this.column, null], oldColumn = ref[0], this.column = ref[1];
        return this.updateAt(oldColumn, this.row);
      } else {
        this.mode = this.VERTICAL;
        this.next_state = this.state.next();
        this.verticals = this.computeVerticals();
        return this.eventAt(0, this.row);
      }
    }
  };

  Eller.prototype.computeVerticals = function() {
    var verts;
    verts = [];
    this.state.foreach((function(_this) {
      return function(id, set) {
        var cellsToConnect, countFromThisSet;
        countFromThisSet = 1 + _this.rand.nextInteger(set.length - 1);
        cellsToConnect = _this.rand.randomizeList(set).slice(0, countFromThisSet);
        return verts = verts.concat(cellsToConnect);
      };
    })(this));
    return verts.sort(function(a, b) {
      return a - b;
    });
  };

  Eller.prototype.verticalStep = function() {
    var oldColumn, ref;
    if (this.verticals.length === 0) {
      this.state = this.next_state.populate();
      this.row += 1;
      oldColumn = this.column;
      this.initializeRow();
      this.eventAt(0, this.row);
      this.updateAt(oldColumn, this.row - 1);
      return this.updateAt(this.column, this.row);
    } else {
      ref = [this.column, this.verticals.pop()], oldColumn = ref[0], this.column = ref[1];
      this.updateAt(oldColumn, this.row);
      this.next_state.add(this.column, this.state.setFor(this.column));
      this.maze.carve(this.column, this.row, Maze.Direction.S);
      this.updateAt(this.column, this.row);
      this.maze.carve(this.column, this.row + 1, Maze.Direction.N);
      return this.updateAt(this.column, this.row + 1);
    }
  };

  Eller.prototype.step = function() {
    switch (this.mode) {
      case this.HORIZONTAL:
        this.horizontalStep();
        break;
      case this.VERTICAL:
        this.verticalStep();
    }
    return this.pending;
  };

  return Eller;

})(Maze.Algorithm);

Maze.Algorithms.Eller.State = (function() {
  function State(width, counter) {
    this.width = width;
    this.counter = counter;
    if (this.counter == null) {
      this.counter = 0;
    }
    this.sets = {};
    this.cells = [];
  }

  State.prototype.next = function() {
    return new Maze.Algorithms.Eller.State(this.width, this.counter);
  };

  State.prototype.populate = function() {
    var base, cell, set;
    cell = 0;
    while (cell < this.width) {
      if (!this.cells[cell]) {
        set = (this.counter += 1);
        ((base = this.sets)[set] != null ? base[set] : base[set] = []).push(cell);
        this.cells[cell] = set;
      }
      cell += 1;
    }
    return this;
  };

  State.prototype.merge = function(sink, target) {
    var cell, i, len, ref, sink_set, target_set;
    sink_set = this.cells[sink];
    target_set = this.cells[target];
    this.sets[sink_set] = this.sets[sink_set].concat(this.sets[target_set]);
    ref = this.sets[target_set];
    for (i = 0, len = ref.length; i < len; i++) {
      cell = ref[i];
      this.cells[cell] = sink_set;
    }
    return delete this.sets[target_set];
  };

  State.prototype.isSame = function(a, b) {
    return this.cells[a] === this.cells[b];
  };

  State.prototype.add = function(cell, set) {
    var base;
    this.cells[cell] = set;
    ((base = this.sets)[set] != null ? base[set] : base[set] = []).push(cell);
    return this;
  };

  State.prototype.setFor = function(cell) {
    return this.cells[cell];
  };

  State.prototype.foreach = function(fn) {
    var id, ref, results, set;
    ref = this.sets;
    results = [];
    for (id in ref) {
      set = ref[id];
      results.push(fn(id, set));
    }
    return results;
  };

  return State;

})();
