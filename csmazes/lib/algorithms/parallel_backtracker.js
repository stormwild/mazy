// Generated by CoffeeScript 1.12.6

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.ParallelBacktracker = (function(superClass) {
  extend(ParallelBacktracker, superClass);

  ParallelBacktracker.prototype.IN = 0x1000;

  ParallelBacktracker.prototype.STACK = 0x2000;

  ParallelBacktracker.prototype.START = 1;

  ParallelBacktracker.prototype.RUN = 2;

  ParallelBacktracker.prototype.DONE = 3;

  function ParallelBacktracker(maze, options) {
    var cell, east, i, j, k, name, north, ref, ref1, south, west, x, y;
    ParallelBacktracker.__super__.constructor.apply(this, arguments);
    this.cells = [];
    this.sets = {};
    for (x = j = 0, ref = maze.height; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      for (y = k = 0, ref1 = maze.width; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
        name = "c" + x + "r" + y;
        north = "c" + x + "r" + (y - 1);
        south = "c" + x + "r" + (y + 1);
        east = "c" + (x + 1) + "r" + y;
        west = "c" + (x - 1) + "r" + y;
        cell = {
          x: x,
          y: y,
          name: name,
          north: north,
          south: south,
          west: west,
          east: east,
          dirs: this.rand.randomDirections()
        };
        this.cells.push(cell);
        this.cells[name] = cell;
      }
    }
    this.state = this.START;
    this.stacks = (function() {
      var l, ref2, ref3, results;
      results = [];
      for (i = l = 1, ref2 = (ref3 = options.input) != null ? ref3 : 2; 1 <= ref2 ? l <= ref2 : l >= ref2; i = 1 <= ref2 ? ++l : --l) {
        results.push([]);
      }
      return results;
    })();
  }

  ParallelBacktracker.prototype.step = function() {
    switch (this.state) {
      case this.START:
        this.startStep();
        break;
      case this.RUN:
        this.runStep();
    }
    return this.state !== this.DONE;
  };

  ParallelBacktracker.prototype.startStep = function() {
    var cell, i, indexes, j, k, ref, ref1, results;
    indexes = this.rand.randomizeList((function() {
      results = [];
      for (var j = 0, ref = this.cells.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this));
    for (i = k = 0, ref1 = this.stacks.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
      cell = this.cells[indexes[i]];
      this.maze.carve(cell.x, cell.y, this.IN | this.STACK);
      this.updateAt(cell.x, cell.y);
      cell.set = "s" + i;
      this.stacks[i] = [cell];
      this.sets[cell.set] = [cell];
    }
    return this.state = this.RUN;
  };

  ParallelBacktracker.prototype.cellAt = function(x, y) {
    return this.cells["c" + x + "r" + y];
  };

  ParallelBacktracker.prototype.runStep = function() {
    var activeStacks, base, cell, current, dir, i, j, k, l, len, len1, n, neighbor, nx, ny, oldSet, ref, ref1, ref2, results, stack;
    activeStacks = 0;
    for (i = j = 0, ref = this.stacks.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      stack = this.stacks[i];
      if (stack.length === 0) {
        continue;
      }
      activeStacks += 1;
      while (true) {
        current = stack[stack.length - 1];
        dir = current.dirs.pop();
        nx = current.x + Maze.Direction.dx[dir];
        ny = current.y + Maze.Direction.dy[dir];
        if (this.maze.isValid(nx, ny)) {
          neighbor = this.cellAt(nx, ny);
          if ((neighbor != null) && current.set !== neighbor.set) {
            stack.push(neighbor);
            this.maze.carve(current.x, current.y, dir);
            this.maze.carve(neighbor.x, neighbor.y, Maze.Direction.opposite[dir] | this.STACK);
            this.updateAt(current.x, current.y);
            oldSet = neighbor.set;
            if ((base = this.sets)[oldSet] == null) {
              base[oldSet] = [neighbor];
            }
            ref1 = this.sets[oldSet];
            for (k = 0, len = ref1.length; k < len; k++) {
              n = ref1[k];
              n.set = current.set;
              this.sets[current.set].push(n);
              this.updateAt(n.x, n.y);
            }
            delete this.sets[oldSet];
            break;
          }
        }
        if (current.dirs.length === 0) {
          this.maze.uncarve(current.x, current.y, this.STACK);
          this.updateAt(current.x, current.y);
          stack.pop();
          break;
        }
      }
    }
    if (activeStacks === 0) {
      this.state = this.DONE;
      ref2 = this.cells;
      results = [];
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        cell = ref2[l];
        cell.set = "final";
        results.push(this.updateAt(cell.x, cell.y));
      }
      return results;
    }
  };

  ParallelBacktracker.prototype.isStack = function(x, y) {
    return this.maze.isSet(x, y, this.STACK);
  };

  return ParallelBacktracker;

})(Maze.Algorithm);
