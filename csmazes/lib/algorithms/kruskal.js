// Generated by CoffeeScript 1.12.6

/*
Author: Jamis Buck <jamis@jamisbuck.org>
License: Public domain, baby. Knock yourself out.

The original CoffeeScript sources are always available on GitHub:
http://github.com/jamis/csmazes
 */
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Maze.Algorithms.Kruskal = (function(superClass) {
  extend(Kruskal, superClass);

  Kruskal.prototype.WEAVE = 1;

  Kruskal.prototype.JOIN = 2;

  function Kruskal(maze, options) {
    var i, j, ref, ref1, ref2, ref3, x, y;
    Kruskal.__super__.constructor.apply(this, arguments);
    this.sets = [];
    this.edges = [];
    for (y = i = 0, ref = this.maze.height; 0 <= ref ? i < ref : i > ref; y = 0 <= ref ? ++i : --i) {
      this.sets.push([]);
      for (x = j = 0, ref1 = this.maze.width; 0 <= ref1 ? j < ref1 : j > ref1; x = 0 <= ref1 ? ++j : --j) {
        this.sets[y].push(new Maze.Algorithms.Kruskal.Tree());
        if (y > 0) {
          this.edges.push({
            x: x,
            y: y,
            direction: Maze.Direction.N
          });
        }
        if (x > 0) {
          this.edges.push({
            x: x,
            y: y,
            direction: Maze.Direction.W
          });
        }
      }
    }
    this.rand.randomizeList(this.edges);
    this.weaveMode = (ref2 = options.weaveMode) != null ? ref2 : "onePhase";
    if (typeof this.weaveMode === "function") {
      this.weaveMode = this.weaveMode();
    }
    this.weaveDensity = (ref3 = options.weaveDensity) != null ? ref3 : 80;
    if (typeof this.weaveDensity === "function") {
      this.weaveDensity = this.weaveDensity();
    }
    this.state = (this.maze.isWeave != null) && this.weaveMode === "twoPhase" ? this.WEAVE : this.JOIN;
  }

  Kruskal.prototype.connect = function(x1, y1, x2, y2, direction) {
    this.sets[y1][x1].connect(this.sets[y2][x2]);
    this.maze.carve(x1, y1, direction);
    this.updateAt(x1, y1);
    this.maze.carve(x2, y2, Maze.Direction.opposite[direction]);
    return this.updateAt(x2, y2);
  };

  Kruskal.prototype.weaveStep = function() {
    var edge, ex, ey, i, len, newEdges, nx, ny, ref, ref1, ref2, ref3, ref4, results, safe, sx, sy, wx, wy;
    if (this.x == null) {
      this.y = 1;
      this.x = 1;
    }
    results = [];
    while (this.state === this.WEAVE) {
      if (this.maze.isBlank(this.x, this.y) && this.rand.nextInteger(100) < this.weaveDensity) {
        ref = [this.x, this.y - 1], nx = ref[0], ny = ref[1];
        ref1 = [this.x - 1, this.y], wx = ref1[0], wy = ref1[1];
        ref2 = [this.x + 1, this.y], ex = ref2[0], ey = ref2[1];
        ref3 = [this.x, this.y + 1], sx = ref3[0], sy = ref3[1];
        safe = !this.sets[ny][nx].isConnectedTo(this.sets[sy][sx]) && !this.sets[wy][wx].isConnectedTo(this.sets[ey][ex]);
        if (safe) {
          this.sets[ny][nx].connect(this.sets[sy][sx]);
          this.sets[wy][wx].connect(this.sets[ey][ex]);
          if (this.rand.nextBoolean()) {
            this.maze.carve(this.x, this.y, Maze.Direction.E | Maze.Direction.W | Maze.Direction.U);
          } else {
            this.maze.carve(this.x, this.y, Maze.Direction.N | Maze.Direction.S | Maze.Direction.U);
          }
          this.maze.carve(nx, ny, Maze.Direction.S);
          this.maze.carve(wx, wy, Maze.Direction.E);
          this.maze.carve(ex, ey, Maze.Direction.W);
          this.maze.carve(sx, sy, Maze.Direction.N);
          this.updateAt(this.x, this.y);
          this.updateAt(nx, ny);
          this.updateAt(wx, wy);
          this.updateAt(ex, ey);
          this.updateAt(sx, sy);
          newEdges = [];
          ref4 = this.edges;
          for (i = 0, len = ref4.length; i < len; i++) {
            edge = ref4[i];
            if ((edge.x === this.x && edge.y === this.y) || (edge.x === ex && edge.y === ey && edge.direction === Maze.Direction.W) || (edge.x === sx && edge.y === sy && edge.direction === Maze.Direction.N)) {
              continue;
            }
            newEdges.push(edge);
          }
          this.edges = newEdges;
          break;
        }
      }
      this.x++;
      if (this.x >= this.maze.width - 1) {
        this.x = 1;
        this.y++;
        if (this.y >= this.maze.height - 1) {
          this.state = this.JOIN;
          results.push(this.eventAt(this.x, this.y));
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Kruskal.prototype.joinStep = function() {
    var edge, edge2, i, index, nx, nx2, ny, ny2, ref, results, set1, set2, set3;
    results = [];
    while (this.edges.length > 0) {
      edge = this.edges.pop();
      nx = edge.x + Maze.Direction.dx[edge.direction];
      ny = edge.y + Maze.Direction.dy[edge.direction];
      set1 = this.sets[edge.y][edge.x];
      set2 = this.sets[ny][nx];
      if ((this.maze.isWeave != null) && this.weaveMode === "onePhase" && this.maze.isPerpendicular(nx, ny, edge.direction)) {
        nx2 = nx + Maze.Direction.dx[edge.direction];
        ny2 = ny + Maze.Direction.dy[edge.direction];
        set3 = null;
        for (index = i = 0, ref = this.edges.length; 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {
          edge2 = this.edges[index];
          if (edge2.x === nx && edge2.y === ny && edge2.direction === edge.direction) {
            this.edges.splice(index, 1);
            set3 = this.sets[ny2][nx2];
            break;
          }
        }
        if (set3 && !set1.isConnectedTo(set3)) {
          this.connect(edge.x, edge.y, nx2, ny2, edge.direction);
          this.performThruWeave(nx, ny);
          this.updateAt(nx, ny);
          break;
        } else if (!set1.isConnectedTo(set2)) {
          this.connect(edge.x, edge.y, nx, ny, edge.direction);
          break;
        } else {
          results.push(void 0);
        }
      } else if (!set1.isConnectedTo(set2)) {
        this.connect(edge.x, edge.y, nx, ny, edge.direction);
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Kruskal.prototype.step = function() {
    switch (this.state) {
      case this.WEAVE:
        this.weaveStep();
        break;
      case this.JOIN:
        this.joinStep();
    }
    return this.edges.length > 0;
  };

  return Kruskal;

})(Maze.Algorithm);

Maze.Algorithms.Kruskal.Tree = (function() {
  function Tree() {
    this.up = null;
  }

  Tree.prototype.root = function() {
    if (this.up) {
      return this.up.root();
    } else {
      return this;
    }
  };

  Tree.prototype.isConnectedTo = function(tree) {
    return this.root() === tree.root();
  };

  Tree.prototype.connect = function(tree) {
    return tree.root().up = this;
  };

  return Tree;

})();
